<!--  -->
<sect1 id="addthings">
<title>Adding Things to Replication</title>

<para>You may discover that you have missed replicating things that
you wish you were replicating.</para>

<para>This can generally be fairly easily remedied.</para>

<para>You cannot directly use <xref linkend="slonik"> <xref
linkend="stmtsetaddtable"> or <xref linkend="stmtsetaddsequence"> in
order to add tables and sequences to a replication set that is
presently replicating; you must instead create a new replication set.
Once it is identically subscribed (e.g. - the set of providers and
subscribers is <emphasis>entirely identical</emphasis> to that for the
set it is to merge with), the sets may be merged together using <xref
linkend="stmtmergeset">.</para>

<para>Up to and including 1.0.2, there was a potential problem where
if <xref linkend="stmtmergeset"> is issued while other
subscription-related events are pending, it is possible for things to
get pretty confused on the nodes where other things were pending.
This problem was resolved in 1.0.5.</para>

<para> Note that if you add nodes, you will need to add both <xref
linkend="stmtstorepath"> statements to indicate how nodes communicate
with one another, and <xref linkend="stmtstorelisten"> statements to
configuration the <quote>communications network</quote> that results
from that.  See <xref linkend="listenpaths"> for more details on the
latter.</para>

<para>It is suggested that you be very deliberate when adding such
things.  For instance, submitting multiple subscription requests for a
particular set in one <xref linkend="slonik"> script often turns out
quite badly.  If it is <emphasis>truly</emphasis> necessary to
automate this, you'll probably want to submit <xref
linkend="stmtwaitevent"> requests in between subscription requests in
order that the <xref linkend="slonik"> script wait for one
subscription to complete processing before requesting the next
one.</para>

<para>But in general, it is likely to be easier to cope with complex
node reconfigurations by making sure that one change has been
successfully processed before going on to the next.  It's way easier
to fix one thing that has broken than to piece things together after
the interaction of five things that have all broken.</para>

<para> Here are a set of <quote>recipes</quote> for how to do various
sorts of modifications to replication configuration:</para>

<itemizedlist>
<listitem><para> Adding a table to replication </para>

<para> &slony1; does not allow you to add a table to a replication set
that is already being replicated. In principle, it would certainly be
<emphasis>possible;</emphasis> what would happen is that the
SET_ADD_TABLE event would lead to the relevant code from the
SUBSCRIBE_SET event being invoked to initialize the table. That would,
regrettably, significantly complicate the logic of all of these
components, so this is not permitted. </para>

<para>Instead, what you must do is thus:

<itemizedlist>
<listitem><para> Add the new table on each node. </para>

<para> In principle, <xref linkend="stmtddlscript"> could be used for
this, but the fact that this leads to <link linkend="locking"> Locking
Issues </link> and requires altering <emphasis>all</emphasis> tables
in some existing replication set, on <emphasis>all</emphasis> nodes,
makes <xref linkend="stmtddlscript"> an unattractive approach on a
busy system.  This breaks the &slony1; feature that you <quote>don't
have to interrupt normal activity to introduce replication.</quote>
</para>

<para> Instead, you can add the table via
<application>psql</application> on each node.

</para> </listitem>

<listitem><Para> Create a new replication set <xref linkend="stmtcreateset">
</para></listitem>
<listitem><para> 
Add the table to the new set <xref linkend="stmtsetaddtable"> 
</para></listitem>
<listitem><para> 
Request subscription <xref linkend="stmtsubscribeset"> for this new set. If there are several nodes, you will need to <xref linkend="stmtsubscribeset"> once for each node that should subscribe.
</para></listitem>
<listitem><para> 
Once the subscriptions have all been set up so that the new set has an identical set of subscriptions to the old set, you can merge the new set in alongside the old one via <xref linkend="stmtmergeset">
</itemizedlist>
</listitem>
<listitem><para> How to add columns to a replicated table </para>

<para> This also answers the question <quote>How do I rename columns
on a replicated table?</quote>, and, more generally, other questions
to the effect of <quote>How do I modify the definitions of replicated
tables?</quote></para>

<para>If you change the <quote>shape</quote> of a replicated table, this needs to take place at exactly the same point in all of the <quote>transaction streams</quote> on all nodes that are subscribed to the set containing the table.</para>

<para> Thus, the way to do this is to construct an SQL script consisting of the DDL changes, and then submit that script to all of the nodes via the Slonik command <xref linkend="stmtddlscript">.

<para> There are a number of <quote>sharp edges</quote> to note...
<itemizedlist>
    <listitem><para> You absolutely <emphasis>must not</emphasis> include transaction control commands, particularly <command>BEGIN</command> and <command>COMMIT</command>, inside these DDL scripts. &slony1; wraps DDL scripts with a <command>BEGIN</command>/<command>COMMIT</command> pair; adding extra transaction control will mean that parts of the DDL will commit outside the control of &slony1; </para></listitem>

    <listitem><Para> Avoid, if possible, having quotes in the DDL script </para> </listitem>
</itemizedlist>

</para></listitem>
<listitem><para> How to remove replication for a node
<para> You will want to remove the various &slony1; components connected to the database(s).</para>

<para> We will just consider, for now, doing this to one node. If you have multiple nodes, you will have to repeat this as many times as necessary.</para>

<para> Components to be Removed: </para>
<itemizedlist>
<listitem><para>    Log Triggers / Update Denial Triggers 

</para></listitem>
<listitem><para>    The "cluster" schema containing &slony1; tables indicating the state of the node as well as various stored functions 
</para></listitem>
<listitem><para>
    <xref linkend="slon"> process that manages the node 
</para></listitem>
<listitem><para>
    Optionally, the SQL and pl/pgsql scripts and &slony1; binaries that are part of the &postgres; build. (Of course, this would make it challenging to restart replication; it is unlikely that you truly need to do this...) 
</para></listitem>
</itemizedlist>

<para> How To Conveniently Handle Removal</para>
<itemizedlist>
<listitem><para>
    You may use the Slonik <xref linkend="stmtdropnode"> command to remove the node from the cluster. This will lead to the triggers and everything in the cluster schema being dropped from the node. The <xref linkend="slon"> process will automatically die off. 
</para></listitem>
<listitem><para>

    In the case of a failed node (where you used <xref linkend="stmtfailover"> to switch to another node), you may need to use <xref linkend="stmtuninstallnode"> to drop out the triggers and schema and functions. 
</para></listitem>
<listitem><para>

    If the above things work out particularly badly, you could submit the SQL command <command>DROP SCHEMA "_ClusterName" CASCADE;</command>, which will drop out &slony1; functions, tables, and triggers alike. 
</para></listitem>
</itemizedlist>
</listitem>

<listitem><para> Adding A Node To Replication</para>

<para>Things are not fundamentally different whether you are adding a brand new, fresh node, or if you had previously dropped a node and are recreating it. In either case, you are adding a node to replication. </para>

<para>The needful steps are thus... </para>
<itemizedlist>
<listitem><para>
   Determine the node number and any relevant DSNs for the new node.  Use &postgres; command <command>createdb</command> to create the database; add the table definitions for the tables that are to be replicated, as &slony1; does not automatically propagate that information.
</para></listitem>
<listitem><para>
   If the node had been a failed node, you may need to issue the <xref linkend="slonik"> command <xref linkend="stmtdropnode"> in order to get rid of its vestiges in the cluster, and to drop out the schema that &slony1; creates.
</para></listitem>
<listitem><para>
    Issue the slonik command <xref linkend="stmtstorenode"> to establish the new node.
</para></listitem>
<listitem><para>
    At this point, you may start a <xref linkend="slon">  daemon against the new node. It may not know much about the other nodes yet, so the logs for this node may be pretty quiet.
</para></listitem>
<listitem><para>
    Issue the slonik command <xref linkend="stmtstorepath"> to indicate how <xref linkend="slon"> processes are to communicate with the new node.  In &slony1; version 1.1 and later, this will then automatically generate <link linkend="listenpaths"> listen path </link> entries; in earlier versions, you will need to use <xref linkend="stmtstorelisten"> to generate them manually.
</para></listitem>
<listitem><para>
   Issue the slonik command <xref linkend="stmtsubscribeset"> to subscribe the node to some replication set. 
</para></listitem>
</itemizedlist>
</listitem>

<listitem><para> How do I reshape the subscriptions?

<para> For instance, I want subscriber node 3 to draw data from node
1, when it is presently drawing data from node 2. </para>

<para> This isn't a case for <xref linkend="stmtmoveset">; we're not
shifting the origin, just reshaping the subscribers. </para>

<para> For this purpose, you can simply submit <xref
linkend="stmtsubscribeset"> requests to <emphasis>revise</emphasis>
the subscriptions.  Subscriptions will not be started from scratch;
they will merely be reconfigured.  </para></listitem>

</itemizedlist>
</sect1>
<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:"book.sgml"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
